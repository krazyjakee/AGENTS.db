use std::collections::BTreeMap;
use std::fs;
use std::path::{Path, PathBuf};

fn find_workspace_lock(start: &Path) -> Option<PathBuf> {
    let mut cur = start.to_path_buf();
    for _ in 0..6 {
        let lock = cur.join("Cargo.lock");
        if lock.exists() {
            return Some(lock);
        }
        if !cur.pop() {
            break;
        }
    }
    None
}

fn parse_lock_versions(lock_text: &str) -> BTreeMap<String, Vec<String>> {
    let mut out: BTreeMap<String, Vec<String>> = BTreeMap::new();
    let mut in_pkg = false;
    let mut name: Option<String> = None;
    let mut version: Option<String> = None;

    for raw_line in lock_text.lines() {
        let line = raw_line.trim();
        if line == "[[package]]" {
            in_pkg = true;
            name = None;
            version = None;
            continue;
        }
        if !in_pkg {
            continue;
        }
        if line.is_empty() {
            continue;
        }
        if let Some(rest) = line.strip_prefix("name = ") {
            name = rest.trim().trim_matches('"').to_string().into();
        } else if let Some(rest) = line.strip_prefix("version = ") {
            version = rest.trim().trim_matches('"').to_string().into();
        }

        if let (Some(n), Some(v)) = (name.as_ref(), version.as_ref()) {
            out.entry(n.clone()).or_default().push(v.clone());
            in_pkg = false;
            name = None;
            version = None;
        }
    }

    for versions in out.values_mut() {
        versions.sort();
        versions.dedup();
    }
    out
}

fn emit(out_dir: &Path, versions: &BTreeMap<String, Vec<String>>) -> std::io::Result<()> {
    let fastembed = versions.get("fastembed").cloned().unwrap_or_default();
    let hf_hub = versions.get("hf-hub").cloned().unwrap_or_default();
    let ureq = versions.get("ureq").cloned().unwrap_or_default();
    let candle_core = versions.get("candle-core").cloned().unwrap_or_default();
    let candle_nn = versions.get("candle-nn").cloned().unwrap_or_default();
    let candle_transformers = versions
        .get("candle-transformers")
        .cloned()
        .unwrap_or_default();
    let tokenizers = versions.get("tokenizers").cloned().unwrap_or_default();

    let render_list = |vals: &[String]| -> String {
        let mut out = String::new();
        out.push_str("&[");
        for (i, v) in vals.iter().enumerate() {
            if i > 0 {
                out.push_str(", ");
            }
            out.push('"');
            out.push_str(v);
            out.push('"');
        }
        out.push(']');
        out
    };

    let mut s = String::new();
    s.push_str("// @generated by crates/agentsdb-embeddings/build.rs\n");
    s.push_str("pub const FASTEMBED_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&fastembed));
    s.push_str(";\n");
    s.push_str("pub const HF_HUB_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&hf_hub));
    s.push_str(";\n");
    s.push_str("pub const UREQ_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&ureq));
    s.push_str(";\n");
    s.push_str("pub const CANDLE_CORE_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&candle_core));
    s.push_str(";\n");
    s.push_str("pub const CANDLE_NN_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&candle_nn));
    s.push_str(";\n");
    s.push_str("pub const CANDLE_TRANSFORMERS_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&candle_transformers));
    s.push_str(";\n");
    s.push_str("pub const TOKENIZERS_VERSIONS: &[&str] = ");
    s.push_str(&render_list(&tokenizers));
    s.push_str(";\n");

    fs::write(out_dir.join("dep_versions.rs"), s)
}

fn main() {
    println!("cargo:rerun-if-changed=../../Cargo.lock");

    let manifest_dir =
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let lock_path = find_workspace_lock(&manifest_dir)
        .or_else(|| find_workspace_lock(&manifest_dir.join("..")))
        .expect("find Cargo.lock");
    let lock_text = fs::read_to_string(&lock_path).expect("read Cargo.lock");
    let versions = parse_lock_versions(&lock_text);

    let out_dir = PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR"));
    emit(&out_dir, &versions).expect("write dep_versions.rs");
}
